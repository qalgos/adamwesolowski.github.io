<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
</head>
<body>
    <py-script>
        import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import numpy as np
import networkx as nx
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import MolDraw2DCairo
import threading
import time
import io
import base64
from PIL import Image, ImageTk
import os
import re
import sys

class DragDropLabel(ttk.Label):
    """A custom label widget that supports drag and drop functionality"""
    def __init__(self, master, callback, **kwargs):
        super().__init__(master, **kwargs)
        self.callback = callback
        self.bind('<Button-1>', self.on_click)
        self['background'] = '#2f4b7c'
        
        # Set up platform-specific drag and drop
        self.setup_drag_and_drop()
        
    def setup_drag_and_drop(self):
        """Set up drag and drop functionality based on platform"""
        try:
            # Try to use native DND for Windows
            if sys.platform == 'win32':
                self.drop_target_register('DND_Files')
                self.dnd_bind('<<Drop>>', self.on_drop)
            # For other platforms, use a simpler approach
            else:
                self.bind('<Enter>', self.on_drag_enter)
                self.bind('<Leave>', self.on_drag_leave)
                # Note: Full drag and drop requires more complex handling on Linux/Mac
        except:
            # Fallback to simple highlighting
            self.bind('<Enter>', self.on_drag_enter)
            self.bind('<Leave>', self.on_drag_leave)
        
    def on_drag_enter(self, event):
        self.configure(background='#ffa600')
        
    def on_drag_leave(self, event):
        self.configure(background='#2f4b7c')
        
    def on_drop(self, event):
        """Handle file drop event (Windows)"""
        self.configure(background='#2f4b7c')
        # Get the dropped file path
        file_path = event.data.strip().strip('{}')
        if file_path:
            self.callback(file_path)
        
    def on_click(self, event):
        file_path = filedialog.askopenfilename(
            title="Select SMILES file",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        if file_path:
            self.callback(file_path)

class MolecularPropertyPredictor:
    def __init__(self, root):
        self.root = root
        self.root.title("HAYAKU: The Best and Fastest Molecular Property Predictor on the Market")
        self.root.geometry("1400x900")
        self.root.configure(bg="#003f5c")
        
        # Initialize datasets and models
        self.datasets = {
            "Lipophilicity (LogP / LogD) [large/small]": {"model": None, "scaler": None, "accuracy": 87.4},
            "Molecular Weight (MW)": {"model": None, "scaler": None, "accuracy": 68.1},
            "Hydrogen Bond Donors and Acceptors (HBD/HBA) [D/A]": {"model": None, "scaler": None, "accuracy": 61.3},
            "Solubility in H20": {"model": None, "scaler": None, "accuracy": 83.6},
            "Ionization / pKa [high/low]": {"model": None, "scaler": None, "accuracy": 71.0}
        }
        
        # Comprehensive molecule database with representatives from all 5 classes
        self.sample_molecules = {
            # AIDS dataset representatives (Anti-HIV activity)
            "AZT (Zidovudine)": "C1=CN(C(=O)N=C1N)C2CC(C(O2)CO)OC3C(C(C(O3)CO)O)O",
            "Efavirenz": "C1C(C(=O)NC2=CC=CC=C2)=C(C(=O)OCC3=CC=CC=C3)N(C1=O)C4=CC=C(C=C4)C#N",
            "Nevirapine": "C1CN(C2=NC=NC(=C2N1)C3=CC=C(C=C3)Cl)C4=CC=CC=C4",
            "Indinavir": "C1CC(C(NC1)C(C(C(CC(=O)OCC2=CC=CC=C2)O)NC(=O)C3=CC=CC=C3)C4=CC=CC=C4)NC(=O)O",
            "Saquinavir": "C1CC(N(C1)C(=O)C2CCCN2C(=O)C3C(CC(C3O)NC(=O)C4=CC=CC=C4)NC(=O)C5=CC=CC=C5)C6=CC=CC=C6",
            
            # NCI1 dataset representatives (Anti-cancer activity)
            "Cisplatin": "N.N.Cl[Pt]Cl",
            "Paclitaxel (Taxol)": "CC1=C2C(C(=O)C3(C(CC4C(C3C(C(C2(C)C)(CC1OC(=O)C5=CC=CC=C5)O)OC(=O)C6=CC=CC=C6)(CO4)OC(=O)C)OC(=O)C7=CC=CC=C7)C",
            "Doxorubicin": "CC1C(C(CC(O1)OC2C(C(C(C(C2O)O)O)OC3C(C(C(C(C3O)O)N)O)O)(C)C)O)(C)C",
            "Methotrexate": "C1=CC(=CC=C1C(=O)NCC2=CN=C3C(=N2)C(=O)NC(=N3)N)NC(=O)C4=CC=C(C=C4)C(=O)NCC(CCC(=O)O)C(=O)O",
            "5-Fluorouracil": "C1=C(C(=O)NC(=O)N1)F",
            
            # PTC-MR dataset representatives (Carcinogenicity in male rats)
            "Benzidine": "C1=CC(=CC=C1N)C2=CC=C(C=C2)N",
            "2-Naphthylamine": "C1=CC=C2C(=C1)C=CC=C2N",
            "Aflatoxin B1": "CC1=C2C3=C(C(=O)CC3)C(=O)O2)C(=C1O)C4=CC5=C(C=C4O)OC5",
            "Vinyl Chloride": "C=CCl",
            "Ethylene Oxide": "C1CO1",
            
            # MUTAG dataset representatives (Mutagenicity)
            "2-Nitrofluorene": "C1=CC=C2C(=C1)C3=CC=CC=C3C2=CC4=CC=CC=C4N(=O)=O",
            "4-Nitroquinoline N-oxide": "C1=CC=C2C(=C1)N=CC(=C2=O)N(=O)=O",
            "Benzo[a]pyrene": "C1=CC2=CC3=CC=CC4=CC=CC(=C43)C=C2C=C1",
            "IQ (2-Amino-3-methylimidazo[4,5-f]quinoline)": "CC1=NC2=CC=CC3=NC=CN23C=N1",
            "Trp-P-2 (3-Amino-1-methyl-5H-pyrido[4,3-b]indole)": "CC1=NC2=CC=CC3=CC=CN23C=N1",
            
            # PROTEINS dataset representatives (Enzyme/Non-enzyme classification)
            "Insulin": "CC1=CN(C(=O)NC1=O)C2CC(C(O2)CO)OC3C(C(C(O3)CO)O)O",  # Simplified representation
            "Cytochrome C": "CC1=CC2=CC=CC3=CC=CN23C=N1",  # Simplified representation
            "Hemoglobin": "C1=CC=C(C=C1)C2=CC=CC=C2",  # Simplified representation
            "Trypsin": "C1CC(C(NC1)C(C(C(CC(=O)OCC3=CC=CC=C3)O)NC(=O)C4=CC=CC=C4)C5=CC=CC=C5)NC(=O)O",  # Simplified
            "Lysozyme": "C1=CN(C(=O)NC1=O)C2CC(C(O2)CO)OC3C(C(C(O3)CO)O)O"  # Simplified representation
        }
        
        # Molecule class information
        self.molecule_classes = {
            # AIDS - Anti-HIV active compounds
            "AZT (Zidovudine)": "AIDS (Active)",
            "Efavirenz": "AIDS (Active)", 
            "Nevirapine": "AIDS (Active)",
            "Indinavir": "AIDS (Active)",
            "Saquinavir": "AIDS (Active)",
            
            # NCI1 - Anti-cancer compounds
            "Cisplatin": "NCI1 (Active)",
            "Paclitaxel (Taxol)": "NCI1 (Active)",
            "Doxorubicin": "NCI1 (Active)", 
            "Methotrexate": "NCI1 (Active)",
            "5-Fluorouracil": "NCI1 (Active)",
            
            # PTC-MR - Carcinogenic compounds
            "Benzidine": "PTC-MR (Carcinogenic)",
            "2-Naphthylamine": "PTC-MR (Carcinogenic)",
            "Aflatoxin B1": "PTC-MR (Carcinogenic)",
            "Vinyl Chloride": "PTC-MR (Carcinogenic)",
            "Ethylene Oxide": "PTC-MR (Carcinogenic)",
            
            # MUTAG - Mutagenic compounds
            "2-Nitrofluorene": "MUTAG (Mutagenic)",
            "4-Nitroquinoline N-oxide": "MUTAG (Mutagenic)",
            "Benzo[a]pyrene": "MUTAG (Mutagenic)",
            "IQ (2-Amino-3-methylimidazo[4,5-f]quinoline)": "MUTAG (Mutagenic)",
            "Trp-P-2 (3-Amino-1-methyl-5H-pyrido[4,3-b]indole)": "MUTAG (Mutagenic)",
            
            # PROTEINS - Enzymes
            "Insulin": "PROTEINS (Enzyme)",
            "Cytochrome C": "PROTEINS (Enzyme)",
            "Hemoglobin": "PROTEINS (Enzyme)", 
            "Trypsin": "PROTEINS (Enzyme)",
            "Lysozyme": "PROTEINS (Enzyme)"
        }
        
        # Initialize batch processing variables
        self.batch_smiles = []
        self.batch_results = []
        self.batch_features = []
        
        # Initialize models (in a real application, these would be pre-trained)
        self.setup_ui()
        self.loading_status("Initializing models...")
        self.initialize_models()
        
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(6, weight=1)
        
        # Title
        title_label = ttk.Label(main_frame, text="HAYAKU: Molecular Property Predictor with Batch Processing", 
                               font=("Arial", 16, "bold"), foreground="#ffa600")
        title_label.grid(row=0, column=0, columnspan=4, pady=(0, 20))
        
        # Drag and drop area for batch processing
        drop_frame = ttk.LabelFrame(main_frame, text="SMILES File Input", padding="10")
        drop_frame.grid(row=1, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 10))
        drop_frame.columnconfigure(0, weight=1)
        
        self.drop_label = DragDropLabel(drop_frame, self.process_file,
            text="Click to browse for a text file containing SMILES strings", 
            foreground="white", justify=tk.CENTER, padding=(20, 40))
        self.drop_label.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        # Molecule selection with filter
        ttk.Label(main_frame, text="Select Molecule:", foreground="white", 
                 background="#003f5c").grid(row=2, column=0, sticky=tk.W, pady=5)
        
        # Filter by class
        ttk.Label(main_frame, text="Filter by Class:", foreground="white", 
                 background="#003f5c").grid(row=2, column=1, sticky=tk.W, pady=5, padx=(20, 0))
        
        self.class_filter_var = tk.StringVar(value="All Classes")
        class_combo = ttk.Combobox(main_frame, textvariable=self.class_filter_var, 
                                  values=["All Classes"] + list(set(self.molecule_classes.values())),
                                  width=20, state="readonly")
        class_combo.grid(row=2, column=2, sticky=tk.W, padx=(5, 0), pady=5)
        class_combo.bind("<<ComboboxSelected>>", self.filter_molecules)
        
        self.molecule_var = tk.StringVar()
        self.molecule_combo = ttk.Combobox(main_frame, textvariable=self.molecule_var, 
                                          values=list(self.sample_molecules.keys()), width=40)
        self.molecule_combo.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), padx=(0, 5), pady=5)
        self.molecule_combo.bind("<<ComboboxSelected>>", self.on_molecule_select)
        
        # Property selection
        ttk.Label(main_frame, text="Select Properties:", foreground="white", 
                 background="#003f5c").grid(row=4, column=0, sticky=tk.W, pady=5)
        
        self.property_vars = {}
        properties_frame = ttk.Frame(main_frame)
        properties_frame.grid(row=4, column=1, columnspan=2, sticky=(tk.W, tk.E), padx=(5, 0), pady=5)
        
        properties = list(self.datasets.keys())
        for i, prop in enumerate(properties):
            var = tk.BooleanVar(value=True)
            self.property_vars[prop] = var
            cb = ttk.Checkbutton(properties_frame, text=prop, variable=var)
            cb.grid(row=0, column=i, padx=5)
        
        # Select all button
        ttk.Button(properties_frame, text="Select All", 
                  command=self.select_all_properties).grid(row=0, column=len(properties), padx=5)
        
        # Predict buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=5, column=0, columnspan=4, pady=20)
        
        predict_button = ttk.Button(button_frame, text="Predict Selected Molecule", 
                                   command=self.predict_properties)
        predict_button.grid(row=0, column=0, padx=5)
        
        batch_predict_button = ttk.Button(button_frame, text="Predict Batch Molecules", 
                                        command=self.predict_batch_properties)
        batch_predict_button.grid(row=0, column=1, padx=5)
        
        export_button = ttk.Button(button_frame, text="Export Results", 
                                  command=self.export_results)
        export_button.grid(row=0, column=2, padx=5)
        
        # Create a paned window for results and visualization
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.grid(row=6, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))
        
        # Results area
        results_frame = ttk.LabelFrame(paned_window, text="Prediction Results", padding="10")
        paned_window.add(results_frame, weight=2)
        
        # Create a text widget for results
        self.results_text = tk.Text(results_frame, height=20, width=60, wrap=tk.WORD)
        self.results_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Add scrollbar to text widget
        scrollbar = ttk.Scrollbar(results_frame, orient=tk.VERTICAL, command=self.results_text.yview)
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.results_text.configure(yscrollcommand=scrollbar.set)
        
        # Right side frame for molecule visualization and plot
        right_frame = ttk.Frame(paned_window)
        paned_window.add(right_frame, weight=1)
        
        # Molecule visualization frame
        viz_frame = ttk.LabelFrame(right_frame, text="Molecule Visualization", padding="10")
        viz_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N), pady=(0, 10))
        viz_frame.columnconfigure(0, weight=1)
        
        # Molecule info
        self.mol_info_label = ttk.Label(viz_frame, text="Select a molecule to view details", 
                                       wraplength=250, justify=tk.LEFT)
        self.mol_info_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 10))
        
        # Molecule image
        self.mol_image_label = ttk.Label(viz_frame)
        self.mol_image_label.grid(row=1, column=0, pady=5)
        
        # Plot frame
        plot_frame = ttk.LabelFrame(right_frame, text="Topological Indices Plot", padding="10")
        plot_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))
        plot_frame.columnconfigure(0, weight=1)
        plot_frame.rowconfigure(0, weight=1)
        
        # Create matplotlib figure for plotting
        self.fig, self.ax = plt.subplots(figsize=(5, 4))
        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=7, column=0, sticky=(tk.W, tk.E))
        
        # Configure grid weights for expansion
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(6, weight=1)
        results_frame.columnconfigure(0, weight=1)
        results_frame.rowconfigure(0, weight=1)
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(1, weight=1)
        plot_frame.columnconfigure(0, weight=1)
        plot_frame.rowconfigure(0, weight=1)
        
        # Apply theme colors
        self.apply_theme()
        
    def apply_theme(self):
        style = ttk.Style()
        style.configure("TFrame", background="#003f5c")
        style.configure("TLabel", background="#003f5c", foreground="white")
        style.configure("TButton", background="#ff6361", foreground="black")
        style.configure("TCheckbutton", background="#003f5c", foreground="white")
        style.configure("TLabelFrame", background="#003f5c", foreground="#ffa600")
        style.configure("TCombobox", fieldbackground="#2f4b7c", foreground="white")
        style.configure("TScrollbar", background="#2f4b7c")
        
        self.results_text.configure(background="#2f4b7c", foreground="white", 
                                  insertbackground="white")
        
    def process_file(self, file_path):
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Extract SMILES strings (simple parsing - can be enhanced)
            self.batch_smiles = []
            for line in content.split('\n'):
                line = line.strip()
                if line and not line.startswith('#'):  # Skip empty lines and comments
                    # Try to extract SMILES (simple approach)
                    parts = line.split()
                    if parts:
                        smiles = parts[0]  # Assume first token is SMILES
                        if self.is_valid_smiles(smiles):
                            self.batch_smiles.append(smiles)
            
            if self.batch_smiles:
                self.drop_label.configure(text=f"Loaded {len(self.batch_smiles)} valid SMILES from {os.path.basename(file_path)}")
                self.status_var.set(f"Loaded {len(self.batch_smiles)} molecules from file")
            else:
                self.drop_label.configure(text="No valid SMILES found in file\nClick to browse for a text file containing SMILES strings")
                messagebox.showerror("Error", "No valid SMILES strings found in the file")
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read file: {str(e)}")
            self.drop_label.configure(text="Error reading file\nClick to browse for a text file containing SMILES strings")
            
    def is_valid_smiles(self, smiles):
        """Basic validation of SMILES string"""
        if not smiles or len(smiles) < 2:
            return False
            
        # Check if it contains at least one letter and valid characters
        if not re.search(r'[a-zA-Z]', smiles):
            return False
            
        # Check for invalid characters (simplified)
        invalid_chars = re.search(r'[^a-zA-Z0-9@+\-\[\]\(\)=#%\.]', smiles)
        if invalid_chars:
            return False
            
        return True
        
    def filter_molecules(self, event=None):
        selected_class = self.class_filter_var.get()
        if selected_class == "All Classes":
            self.molecule_combo['values'] = list(self.sample_molecules.keys())
        else:
            filtered_molecules = [mol for mol, cls in self.molecule_classes.items() if cls == selected_class]
            self.molecule_combo['values'] = filtered_molecules
        
        if self.molecule_combo['values']:
            self.molecule_combo.current(0)
            self.on_molecule_select()
        else:
            self.molecule_var.set("")
        
    def select_all_properties(self):
        for var in self.property_vars.values():
            var.set(True)
    
    def on_molecule_select(self, event=None):
        molecule_name = self.molecule_var.get()
        if molecule_name in self.sample_molecules:
            smiles = self.sample_molecules[molecule_name]
            self.show_molecule_structure(smiles, molecule_name)
    
    def show_molecule_structure(self, smiles, molecule_name):
        try:
            mol = Chem.MolFromSmiles(smiles)
            if mol:
                # Create molecule image
                drawer = MolDraw2DCairo(300, 200)
                drawer.DrawMolecule(mol)
                drawer.FinishDrawing()
                
                # Convert to PNG image
                png_data = drawer.GetDrawingText()
                bio = io.BytesIO(png_data)
                img = Image.open(bio)
                photo = ImageTk.PhotoImage(img)
                
                # Update image label
                self.mol_image_label.configure(image=photo)
                self.mol_image_label.image = photo  # Keep a reference
                
                # Update molecule info
                mol_class = self.molecule_classes.get(molecule_name, "Unknown class")
                self.mol_info_label.configure(
                    text=f"Molecule: {molecule_name}\n"
                         f"Class: {mol_class}\n"
                         f"SMILES: {smiles}"
                )
            else:
                self.mol_image_label.configure(image='')
                self.mol_info_label.configure(text="Could not parse molecule")
        except Exception as e:
            self.mol_image_label.configure(image='')
            self.mol_info_label.configure(text=f"Error rendering molecule: {str(e)}")
    
    def loading_status(self, message):
        self.status_var.set(message)
        self.root.update()
    
    def initialize_models(self):
        # In a real application, this would load pre-trained models
        # For this demo, we'll just simulate the loading process
        def load_models():
            for dataset in self.datasets:
                time.sleep(0.5)  # Simulate loading time
                self.loading_status(f"Loading {dataset} model...")
            
            self.loading_status("Models initialized successfully")
            self.status_var.set("Ready")
        
        # Run in a separate thread to avoid freezing the UI
        thread = threading.Thread(target=load_models)
        thread.daemon = True
        thread.start()
    
    def calculate_wiener_index(self, graph):
        """Calculate Wiener index for a graph"""
        if not graph.nodes:
            return 0
        
        try:
            all_pairs = nx.all_pairs_shortest_path_length(graph)
            total = 0
            for source, targets in all_pairs:
                for target, distance in targets.items():
                    if source != target:
                        total += distance
            return total / 2  # Each pair counted twice
        except:
            return 0
    
    def calculate_estrada_index(self, graph):
        """Calculate Estrada index for a graph"""
        if not graph.nodes:
            return 0
        
        try:
            laplacian = nx.laplacian_matrix(graph).todense()
            eigenvalues = np.linalg.eigvals(laplacian)
            return np.sum(np.exp(eigenvalues))
        except:
            return 0
    
    def calculate_randic_index(self, graph):
        """Calculate Randic index for a graph"""
        if not graph.edges:
            return 0
        
        try:
            total = 0
            for u, v in graph.edges:
                deg_u = graph.degree(u)
                deg_v = graph.degree(v)
                if deg_u > 0 and deg_v > 0:
                    total += 1 / np.sqrt(deg_u * deg_v)
            return total
        except:
            return 0
    
    def smiles_to_graph(self, smiles):
        """Convert SMILES string to a graph representation"""
        try:
            mol = Chem.MolFromSmiles(smiles)
            if not mol:
                return None
            
            graph = nx.Graph()
            
            # Add atoms as nodes
            for atom in mol.GetAtoms():
                graph.add_node(atom.GetIdx(), element=atom.GetSymbol())
            
            # Add bonds as edges
            for bond in mol.GetBonds():
                graph.add_edge(bond.GetBeginAtomIdx(), bond.GetEndAtomIdx(), 
                              bond_type=bond.GetBondType())
            
            return graph
        except:
            return None
    
    def extract_features(self, graph):
        """Extract topological indices from a graph"""
        if graph is None:
            return np.zeros(3)
        
        wiener = self.calculate_wiener_index(graph)
        estrada = self.calculate_estrada_index(graph)
        randic = self.calculate_randic_index(graph)
        
        return np.array([wiener, estrada, randic])
    
    def predict_properties(self):
        molecule_name = self.molecule_var.get()
        if not molecule_name:
            messagebox.showerror("Error", "Please select a molecule")
            return
        
        selected_properties = [prop for prop, var in self.property_vars.items() if var.get()]
        if not selected_properties:
            messagebox.showerror("Error", "Please select at least one property")
            return
        
        smiles = self.sample_molecules[molecule_name]
        
        # Show loading status
        self.loading_status("Calculating topological indices...")
        
        # Calculate features in a separate thread to avoid UI freezing
        def calculate_and_predict():
            try:
                graph = self.smiles_to_graph(smiles)
                if graph is None:
                    self.root.after(0, lambda: messagebox.showerror("Error", "Invalid molecule structure"))
                    return
                
                features = self.extract_features(graph)
                
                # In a real application, we would use pre-trained models
                # For this demo, we'll simulate predictions based on the paper's results
                results = {}
                for prop in selected_properties:
                    # Simulate prediction based on the accuracy reported in the paper
                    accuracy = self.datasets[prop]["accuracy"]
                    
                    # For demonstration, base prediction on molecule class
                    mol_class = self.molecule_classes.get(molecule_name, "")
                    if prop in mol_class:
                        prediction = True  # More likely to be active if molecule is from that class
                        confidence = min(95, accuracy + 10)  # Boost confidence for class matches
                    else:
                        prediction = np.random.random() < (accuracy / 100)
                        confidence = accuracy
                    
                    results[prop] = {
                        "prediction": "Active" if prediction else "Inactive",
                        "confidence": confidence,
                        "features": features
                    }
                
                # Update UI with results
                self.root.after(0, lambda: self.display_results(molecule_name, results, features))
                self.loading_status("Prediction complete")
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("Error", f"Prediction failed: {str(e)}"))
                self.loading_status("Prediction failed")
        
        thread = threading.Thread(target=calculate_and_predict)
        thread.daemon = True
        thread.start()
    
    def predict_batch_properties(self):
        if not self.batch_smiles:
            messagebox.showerror("Error", "Please load a file with SMILES strings first")
            return
            
        selected_properties = [prop for prop, var in self.property_vars.items() if var.get()]
        if not selected_properties:
            messagebox.showerror("Error", "Please select at least one property")
            return
            
        # Show loading status
        self.loading_status(f"Processing {len(self.batch_smiles)} molecules...")
        
        # Process in a separate thread to avoid UI freezing
        def process_batch():
            try:
                self.batch_results = []
                self.batch_features = []
                
                for i, smiles in enumerate(self.batch_smiles):
                    self.root.after(0, lambda: self.loading_status(f"Processing molecule {i+1}/{len(self.batch_smiles)}"))
                    
                    graph = self.smiles_to_graph(smiles)
                    if graph is None:
                        # Skip invalid molecules
                        continue
                        
                    features = self.extract_features(graph)
                    self.batch_features.append(features)
                    
                    # Simulate predictions for each property
                    molecule_results = {}
                    for prop in selected_properties:
                        accuracy = self.datasets[prop]["accuracy"]
                        prediction = np.random.random() < (accuracy / 100)
                        confidence = accuracy if prediction else 100 - accuracy
                        
                        molecule_results[prop] = {
                            "prediction": "Active" if prediction else "Inactive",
                            "confidence": confidence
                        }
                    
                    self.batch_results.append({
                        "smiles": smiles,
                        "results": molecule_results,
                        "features": features
                    })
                
                # Update UI with results
                self.root.after(0, lambda: self.display_batch_results(selected_properties))
                self.root.after(0, lambda: self.plot_features())
                self.loading_status(f"Batch processing complete - {len(self.batch_results)} molecules processed")
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror("Error", f"Batch processing failed: {str(e)}"))
                self.loading_status("Batch processing failed")
        
        thread = threading.Thread(target=process_batch)
        thread.daemon = True
        thread.start()
    
    def display_results(self, molecule_name, results, features):
        """Display prediction results in the text widget"""
        self.results_text.delete(1.0, tk.END)
        
        # Display molecule information
        self.results_text.insert(tk.END, f"Molecule: {molecule_name}\n")
        self.results_text.insert(tk.END, f"Class: {self.molecule_classes.get(molecule_name, 'Unknown')}\n")
        self.results_text.insert(tk.END, f"SMILES: {self.sample_molecules[molecule_name]}\n")
        self.results_text.insert(tk.END, "-" * 60 + "\n\n")
        
        # Display calculated features
        self.results_text.insert(tk.END, "Topological Indices Calculated:\n")
        self.results_text.insert(tk.END, f"  Wiener Index: {features[0]:.2f}\n")
        self.results_text.insert(tk.END, f"  Estrada Index: {features[1]:.2f}\n")
        self.results_text.insert(tk.END, f"  Randic Index: {features[2]:.2f}\n\n")
        
        # Display predictions
        self.results_text.insert(tk.END, "Property Predictions:\n")
        for prop, result in results.items():
            confidence_color = "#4CAF50" if result['confidence'] > 70 else "#FFC107" if result['confidence'] > 50 else "#F44336"
            self.results_text.insert(tk.END, f"  {prop}: {result['prediction']} ")
            self.results_text.insert(tk.END, f"(Confidence: {result['confidence']}%)\n", f"confidence_{prop}")
            self.results_text.tag_config(f"confidence_{prop}", foreground=confidence_color)
        
        self.results_text.insert(tk.END, "\n" + "-" * 60 + "\n")
        self.results_text.insert(tk.END, "Note: Predictions based on topological indices and\n")
        self.results_text.insert(tk.END, "simulated models for demonstration purposes.\n")
        
        # Highlight positive predictions
        self.highlight_predictions(results)
    
    def display_batch_results(self, selected_properties):
        """Display batch prediction results in the text widget"""
        self.results_text.delete(1.0, tk.END)
        
        # Display summary
        self.results_text.insert(tk.END, f"Batch Processing Results\n")
        self.results_text.insert(tk.END, f"Processed {len(self.batch_results)} molecules\n")
        self.results_text.insert(tk.END, "-" * 60 + "\n\n")
        
        # Display results for each molecule
        for i, result in enumerate(self.batch_results):
            self.results_text.insert(tk.END, f"Molecule {i+1}:\n")
            self.results_text.insert(tk.END, f"SMILES: {result['smiles']}\n")
            
            # Display topological indices
            features = result['features']
            self.results_text.insert(tk.END, f"  Wiener Index: {features[0]:.2f}\n")
            self.results_text.insert(tk.END, f"  Estrada Index: {features[1]:.2f}\n")
            self.results_text.insert(tk.END, f"  Randic Index: {features[2]:.2f}\n")
            
            # Display predictions
            for prop in selected_properties:
                pred_result = result['results'][prop]
                confidence_color = "#4CAF50" if pred_result['confidence'] > 70 else "#FFC107" if pred_result['confidence'] > 50 else "#F44336"
                self.results_text.insert(tk.END, f"  {prop}: {pred_result['prediction']} ")
                self.results_text.insert(tk.END, f"(Confidence: {pred_result['confidence']}%)\n", f"confidence_{prop}_{i}")
                self.results_text.tag_config(f"confidence_{prop}_{i}", foreground=confidence_color)
            
            self.results_text.insert(tk.END, "\n")
        
        self.results_text.insert(tk.END, "-" * 60 + "\n")
        self.results_text.insert(tk.END, "Note: Predictions based on topological indices and\n")
        self.results_text.insert(tk.END, "simulated models for demonstration purposes.\n")
    
    def plot_features(self):
        """Plot the computed indices for all molecules in the batch"""
        if not self.batch_features:
            return
            
        # Clear previous plot
        self.ax.clear()
        
        # Prepare data for plotting
        features = np.array(self.batch_features)
        n_molecules = features.shape[0]
        
        # Create bar plot
        x = np.arange(n_molecules)
        width = 0.25
        
        # Normalize features for better visualization
        normalized_features = features / np.max(features, axis=0)
        
        self.ax.bar(x - width, normalized_features[:, 0], width, label='Wiener Index')
        self.ax.bar(x, normalized_features[:, 1], width, label='Estrada Index')
        self.ax.bar(x + width, normalized_features[:, 2], width, label='Randic Index')
        
        # Configure plot
        self.ax.set_xlabel('Molecule Index')
        self.ax.set_ylabel('Normalized Index Value')
        self.ax.set_title('Topological Indices for Batch Molecules')
        self.ax.set_xticks(x)
        self.ax.legend()
        
        # Rotate x labels if there are many molecules
        if n_molecules > 10:
            plt.setp(self.ax.get_xticklabels(), rotation=45, ha='right')
        
        self.fig.tight_layout()
        self.canvas.draw()
    
    def export_results(self):
        """Export results to a text file"""
        if not self.batch_results:
            messagebox.showerror("Error", "No results to export")
            return
            
        file_path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if not file_path:
            return
            
        try:
            with open(file_path, 'w') as f:
                f.write("Molecular Property Prediction Results\n")
                f.write("=" * 50 + "\n\n")
                
                f.write(f"Generated on: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Number of molecules processed: {len(self.batch_results)}\n\n")
                
                for i, result in enumerate(self.batch_results):
                    f.write(f"Molecule {i+1}:\n")
                    f.write(f"SMILES: {result['smiles']}\n")
                    
                    # Write topological indices
                    features = result['features']
                    f.write(f"  Wiener Index: {features[0]:.2f}\n")
                    f.write(f"  Estrada Index: {features[1]:.2f}\n")
                    f.write(f"  Randic Index: {features[2]:.2f}\n")
                    
                    # Write predictions
                    for prop, pred_result in result['results'].items():
                        f.write(f"  {prop}: {pred_result['prediction']} (Confidence: {pred_result['confidence']}%)\n")
                    
                    f.write("\n")
                
                f.write("=" * 50 + "\n")
                f.write("Note: Predictions based on topological indices and simulated models for demonstration purposes.\n")
            
            messagebox.showinfo("Success", f"Results exported to {file_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export results: {str(e)}")
    
    def highlight_predictions(self, results):
        """Highlight positive predictions in the results text"""
        for prop, result in results.items():
            if result['prediction'] == 'Active':
                # Find the position of this prediction in the text
                start_idx = self.results_text.search(
                    f"{prop}: {result['prediction']}", 1.0, tk.END)
                if start_idx:
                    end_idx = f"{start_idx}+{len(prop)+2}c"
                    self.results_text.tag_add("highlight", start_idx, end_idx)
        
        # Configure highlight tag
        self.results_text.tag_config("highlight", background="#ff6361", foreground="black")

def main():
    root = tk.Tk()
    app = MolecularPropertyPredictor(root)
    root.mainloop()

if __name__ == "__main__":
    main()
    </py-script>
</body>
</html>
